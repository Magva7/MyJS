// Функция, в которую мы подаем аргумент number1
// function changePrimitive(number1) {
//     console.log("Меняем значение number1...");
//     console.log("сначала: number1 = " + number1);
//
//     number1 = 5;
//     console.log("потом: number1 = " + number1);
// }
//
// var number2 = 7;
// changePrimitive(number2); // подали внутрь функции аргумент number2, т.е. у нас теперь number1 = number2
// console.log("после отработки функции number2 = "+ number2);
// console.log(number2); //number 2 = 7, т.е. это он внутри функции поменялся, а снаружи, как бы, так и остался = 7

function changeObject(objValue) {
    console.log("Изначальное значение параметра в объекте, который передали в переменную: ");
    console.log(objValue);

    objValue.x = 5;
    console.log("Значение параметра объекта после изменения, внутри функции: ");
    console.log(objValue);
}

value = { x: 7 };
changeObject(value); // objValue = value
console.log("Значение параметра в объекте после того, как функция отработала = 5, т.е. поменялось, хотя меняли" +
    " внутри функции:");
console.log(value);

/*Т.е. итоговая мысль в том, что если передаем внутрь функции какую-нибудь обычную (примитивную) переменную и там
 внутри функции с этой переменной что-то делаем, например меняем ее значение, то изначальное значение переменной,
  которая снаружи останется прежним, т.к. меняли-то мы внутри функции, значит снаружи все осталось как было. А вот
   если мы передаем внутрь функции какой-то объект или его параметр и там внутри его колбасим и с ним играемся, то и
    значение этого параметра изменится даже снаружи, хотя меняли мы его внутри функции. Оно там потому что
     примитивные или обычные переменные это обычные, т.е. если мы внутри функции меняем переменную, которую передали
      снаружи, то создается как бы копия этой переменной и она уже меняется, а объекты это как бы ссылочные, поэтому
       если меняем у объекта что-то внутри функции, то меняется и снаружи, т.к. они все ссылаются в одно место*/